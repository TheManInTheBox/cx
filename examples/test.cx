/*
This file contains test cases for all language features.
If a language feature is implemented, the test should
be located in this file.
*/

int assembly_test_0(int i){
	
	int a;
	asm iconst 0x3E8;	// Load 1000
	asm istore a;		// a = 1000
	
	asm{
		iconst 0b11111111 		// Load 255
		iload a		     		// Load 1000 (a == 1000)
		iadd				 	// a + 255 = 1255
		iload i			 		// Load 100 (if i == 100)
		iadd				 	// 1255 + 100 = 1355
		istore i			 	// i = 1355
		iload i          		// Load 1355
		istore assembly_test_0 	// assembly_test_0 = 1355
		ret						// return
	}
}

// Radix testing
byte binary_test_0(){
	return 0b11111111;
}

// Radix testing
byte hex_test_0(){
	return 0xff;
}

// Radix testing
byte octal_test_0(){
	return 0377;
}

/*
int operator_test_0(){
	bool return_passing = false;
	
	int i = 0;
	char c = 'a';
	real r = 2.0;
	byte z0 = 0b11111111;	// 255
	byte z1 = 0xff;			// 255
	
	return z0;
}
*/

// Basic performance testing
int benchmark_test_0(){
	int s = 0;
	int i = 0;
	int j = 0;
	
	for (; j < 10000;) s += i++ * j++; 
	
	return s;
}

int benchmark_test_1(){
	int s = 0;
	int i = 0;
	int j = 0;
	
	for (; i < 10000;i++)
		for (j = 0; j < 10000;j++) 
			s += i * j; 
	
	return s;
}

// Recursion testing
int recursive_test_0(int count){
	// 69 seems to be the native call stack limit
	// for a release build. Debug build may be more
	// forgiving.
	if(count == 69) return count;
	
	// count++ will continue to pass initial value of
	// count(0) and cause a stack overflow.
	return recursive_test_0(++count);
}

// while loop tests
int while_test_0(int count){
	int a = 3;
	int b = 6;
	int c = 0;
	int d = 5;
	int i = 0;

	while(i < count){
		c += a++ * b++ + d++;
		i++;
	}
	
	return c;
}

// if statement tests
int if_test_0(int count){
	int i = 0;
	int return_value = 50;
	
	while(i < count){
		if(i >= return_value){
			i = 0;
			while(i < return_value) i++;
			
			return i;
		} else {
			i++;
		}
		
		if((i % 2) == 0){
			// even number
			int dummy = 0;
		} else {
			// odd number
			int dummy = 5;
		}
	}
	
	return 0;
}

// Do loop testing
int do_test_0(int count){
	int i = 0;
	int a = 0;
	
	do{
		a = i;
	} while(i++ < count);
	
	return a;
}

// Break testing
int break_test_0(int count){
	int i = 0;
	
	do{
		i++;
		if(i == count) break;
	}while(i < count + 5);
	
	return i;
}

int break_test_1(int count){
	int i = 0;
	
	while(true){
		i++;
		if(i == count) break;
	}
	
	return i;
}

// For loop testing
int for_test_0(int count){
	int a = 0;

	for(int i = 0; i < count; i++){
		a = i;
	}
	
	for(int i = 0; i < count; i++){
		a = i;
	}
	
	int i = 0;
	for(a = 0; a < count;){
		i = a;
		a++;
	}
	
	for(;a < count + 100;){
		a++;
	}
	
	for(;;){
		if(a++ == 1000) break;
	}
	
	return count;
}

bool for_test_0_pass = (for_test_0(100) == 100);
bool while_pass = (while_test_0(100) == 380150);
bool if_pass = (if_test_0(200) == 50);
bool do_pass = (do_test_0(100) == 100);
bool break_0_pass = (break_test_0(20) == 20);
bool break_1_pass = (break_test_1(100) == 100);
bool recursive_test_0_pass = (recursive_test_0(0) == 50);
bool binary_test_0_pass = (binary_test_0() == 255);
bool hex_test_0_pass = (hex_test_0() == 255);
bool octal_test_0_pass = (octal_test_0() == 255);
bool assembly_test_0_pass = (assembly_test_0(100) == 1355);

// TEST HOOK
// return benchmark_test_1();

return benchmark_test_0();