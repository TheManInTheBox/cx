enum enum_value_1 : byte {
	E0 = 10,
	E1 = 20,
	E2 = 30
}

enum enum_value_0 {
	E0,
	E1, 
	E2 = 5
}

enum_value_0 enum_test_0(enum_value_0 e2){
	return e2;
}


enum_value_1 enum_test_1(enum_value_1 e2){
	return e2
}

bool enum_test_0_pass = (enum_test_0(enum_value_0.E2) == enum_value_0.E2);
enum_test_0(enum_value_0.E0);
enum_test_0(enum_value_0.E1);
enum_test_0(enum_value_0::E2);

enum_test_1(enum_value_1.E0);
enum_test_1(enum_value_1.E1);
enum_test_1(enum_value_1::E2);

// Euclidean Greatest Common Divisor (GCD) algorithm
int igcd(int x,  int y){
	if(x == y){
		return x;
	}else if(x < y){
		return igcd(x, y - x);
	}
	
	return igcd(x - y, y);
}

// Binary numeral system (base 2) square root (integer)
int isqrt(int num) {
    int res = 0;
    int bit = 1 << 62; // The second-to-top bit is set: 1 << 30 for 32 bits
 
    // "bit" starts at the highest power of four <= the argument.
    while (bit > num)
        bit >>= 1;
        
    while (bit != 0) {
        if (num >= res + bit) {
            num -= res + bit;
            res = (res >> 1) + bit;
        }
        else
            res >>= 1;
			
        bit >>= 2;
    }
	
    return res;
}

int neg_test_0(int i){
	return -i;
}

int pos_test_0(int i){
	return +i;
}

real neg_test_1(real d){
	return -d;
}

real pos_test_1(real d){
	return +d;
}

int assembly_test_0(int i){
	
	int a;
	asm iconst 0x3E8;	// Load 1000
	asm istore a;		// a = 1000
	
	asm{
		iconst 0b11111111 		// Load 255
		iload a		     		// Load 1000 (a == 1000)
		iadd				 	// a + 255 = 1255
		iload i			 		// Load 100 (if i == 100)
		iadd				 	// 1255 + 100 = 1355
		istore i			 	// i = 1355
		iload i          		// Load 1355
		istore assembly_test_0 	// assembly_test_0 = 1355
		ret						// return
	}
}

// Radix testing
byte binary_test_0(){
	return 0b11111111;
}

// Radix testing
byte hex_test_0(){
	return 0xff;
}

// Radix testing
byte octal_test_0(){
	return 0377;
}

bool operator_test_0(){
	bool return_passing = false;
	
	int i = 1;
	
	i++;
	i--;
	++i;
	--i;
	
	i = -i;
	i = +i;
	
	i += 1;
	i -= 1;
	
	i *= 2;
	i /= 2;
	i++;
	
	i %= 2;
	
	i <<= 2;
	i >>= 1;
	i &= 1;
	i ^= 1;
	i |= 1;
	
	char c = 'a';
	c++;
	c--;
	++c;
	--c;
	
	c += 1;
	c -= 1;
	
	real r = 2.0;
	
	r++;
	r--;
	++r;
	--r;
	
	r += 1.0;
	r -= 1.0;
	
	r *= 50.5;
	r /= 2.0;
	r++;
	
	r %= 2.0;
	
	real rr = (r + 3.0) / 1.0;
	
	byte z0 = 0b11111111;	// 255
	byte z1 = 0xff;			// 255
	
	z0++;
	z0--;
	++z0;
	--z0;
	
	z0 += 1;
	z0 -= 1;
	
	z0 *= 2;
	z0 /= 2;
	z0++;
	
	z0 %= 2;	// i == 1;
	
	z0 <<= 2;
	z0 >>= 1;
	z0 &= 1;
	z0 ^= 1;
	z0 |= 1;
	
	return true;
}

// Basic performance testing
int benchmark_test_0(){
	int s = 0;
	int i = 0;
	int j = 0;
	
	for (; j < 10000;) s += i++ * j++; 
	
	return s;
}

int benchmark_test_1(){
	int s = 0;
	int i = 0;
	int j = 0;
	
	for (; i < 10000;i++)
		for (j = 0; j < 10000;j++) 
			s += i * j; 
	
	return s;
}

// Recursion testing
int recursive_test_0(int count){
	// 69 seems to be the native call stack limit
	// for a release build. Debug build may be more
	// forgiving.
	if(count == 50) return count;
	
	// count++ will continue to pass initial value of
	// count(0) and cause a stack overflow.
	return recursive_test_0(++count);
}

// while loop tests
int while_test_0(int count){
	int a = 3;
	int b = 6;
	int c = 0;
	int d = 5;
	int i = 0;

	while(i < count){
		c += a++ * b++ + d++;
		i++;
	}
	
	return c;
}

// if statement tests
int if_test_0(int count){
	int i = 0;
	int return_value = 50;
	
	while(i < count){
		if(i >= return_value){
			i = 0;
			while(i < return_value) i++;
			
			return i;
		} else {
			i++;
		}
		
		if((i % 2) == 0){
			// even number
			int dummy = 0;
		} else {
			// odd number
			int dummy = 5;
		}
	}
	
	return 0;
}

int if_test_1(int i){
	if(i > 0)
		i = 5;
	else
		i = 10;
		
	return i;
}

// Do loop testing
int do_test_0(int count){
	int i = 0;
	int a = 0;
	
	do{
		a = i;
	} while(i++ < count);
	
	return a;
}

// Break testing
int break_test_0(int count){
	int i = 0;
	
	do{
		i++;
		if(i == count) break;
	}while(i < count + 5);
	
	return i;
}

int break_test_1(int count){
	int i = 0;
	
	while(true){
		i++;
		if(i == count) break;
	}
	
	return i;
}

// For loop testing
int for_test_0(int count){
	int a = 0;

	for(int i = 0; i < count; i++){
		a = i;
	}
	
	for(int i = 0; i < count; i++){
		a = i;
	}
	
	int i = 0;
	for(a = 0; a < count;){
		i = a;
		a++;
	}
	
	for(;a < count + 100;){
		a++;
	}
	
	for(;;){
		if(a++ == 1000) break;
	}
	
	return count;
}

bool for_test_0_pass = (for_test_0(100) == 100);
bool while_pass = (while_test_0(100) == 380150);
bool if_pass = (if_test_0(200) == 50);
bool do_pass = (do_test_0(100) == 100);
bool break_0_pass = (break_test_0(20) == 20);
bool break_1_pass = (break_test_1(100) == 100);
bool recursive_test_0_pass = (recursive_test_0(0) == 50);
bool binary_test_0_pass = (binary_test_0() == 255);
bool hex_test_0_pass = (hex_test_0() == 255);
bool octal_test_0_pass = (octal_test_0() == 255);
bool assembly_test_0_pass = (assembly_test_0(100) == 1355);
bool operator_test_0_pass = operator_test_0();
bool pos_test_0_pass = (pos_test_0(-5) == 5);
bool neg_test_0_pass = (neg_test_0(5) == -5);
bool pos_test_1_pass = (pos_test_1(-5.5) == 5.5);
bool neg_test_1_pass = (neg_test_1(5.5) == -5.5);
bool gcd_pass = (igcd(100,1000) == 100);
bool sqr_root_pass = (isqrt(1048576) == 1024);
//bool if_test_1_pass = (if_test_1(1) == 5);
//bool if_test_1_pass = (if_test_1(-1) == 10);

// TEST HOOK
// return benchmark_test_1();
// return benchmark_test_0();

return sqr_root_pass;