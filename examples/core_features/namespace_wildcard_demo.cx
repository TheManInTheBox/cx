// CX Language - Namespace Wildcard Event Demo
// Demonstrates events across different scopes and namespaces using 'any' wildcards

print("=== CX Language Namespace Wildcard Event Demo ===");

// ===============================================
// GLOBAL SCOPE EVENT HANDLERS
// ===============================================

// Global handler for all user interactions across any namespace
on user.any.input (payload) {
    print("ğŸŒ GLOBAL: User input detected from ANY namespace - " + payload.message);
}

// Global handler for all system events across any namespace  
on system.any.ready (payload) {
    print("ğŸŒ GLOBAL: System component ready from ANY namespace - " + payload.component);
}

// Complex wildcard pattern - joins multiple event busses
on agent.any.thinking.any.complete (payload) {
    print("ğŸŒ GLOBAL: Agent thinking complete across ANY namespace - " + payload.thought);
}

// Global handler for all AI responses across any service
on ai.any.response (payload) {
    print("ğŸŒ GLOBAL: AI response from ANY service - " + payload.response);
}

// ===============================================
// AGENT CLASSES WITH NAMESPACE SCOPING
// ===============================================

class ChatAgent {
    // Class-scoped handlers (registered in ChatAgent namespace)
    
    on user.chat.message (payload) {
        print("ğŸ’¬ CHAT AGENT: Received chat message - " + payload.text);
        
        // Emit to chat namespace
        emit ai.chat.thinking, { prompt: payload.text };
        
        // Think using cognitive methods (fire-and-forget)
        this.Think("Processing chat: " + payload.text);
    }
    
    on ai.chat.thinking (payload) {
        print("ğŸ’¬ CHAT AGENT: Processing thought - " + payload.prompt);
        
        // Complete the thinking process
        emit agent.chat.thinking.complete, { 
            thought: "Chat analysis complete for: " + payload.prompt 
        };
    }
    
    // Handler for any voice-related events (cross-namespace)
    on voice.any.command (payload) {
        print("ğŸ’¬ CHAT AGENT: Received voice command from ANY voice namespace - " + payload.command);
        
        // Convert voice to chat
        emit user.chat.message, { text: "Voice: " + payload.command };
    }
}

class VoiceAgent {
    // Class-scoped handlers (registered in VoiceAgent namespace)
    
    on user.voice.input (payload) {
        print("ğŸ¤ VOICE AGENT: Received voice input - " + payload.audio);
        
        // Process voice input
        emit voice.processing.started, { audio: payload.audio };
        
        // Use cognitive methods for voice processing
        this.Think("Processing voice: " + payload.audio);
    }
    
    on voice.processing.started (payload) {
        print("ğŸ¤ VOICE AGENT: Processing audio - " + payload.audio);
        
        // Convert to command
        emit voice.command.recognized, { 
            command: "Recognized: " + payload.audio 
        };
    }
    
    on voice.command.recognized (payload) {
        print("ğŸ¤ VOICE AGENT: Command recognized - " + payload.command);
        
        // Emit to any namespace that handles voice commands
        emit voice.any.command, { command: payload.command };
    }
    
    // Handler for any system audio events
    on system.any.audio (payload) {
        print("ğŸ¤ VOICE AGENT: System audio event from ANY namespace - " + payload.event);
    }
}

class SystemMonitor {
    // Class-scoped handlers (registered in SystemMonitor namespace)
    
    on system.startup.complete (payload) {
        print("ğŸ“Š SYSTEM MONITOR: Startup complete - " + payload.services);
        
        // Notify all namespaces that system is ready
        emit system.audio.ready, { component: "Audio System" };
        emit system.chat.ready, { component: "Chat System" };
        emit system.network.ready, { component: "Network System" };
    }
    
    // Monitor any critical events across all namespaces
    on any.any.critical (payload) {
        print("ğŸ“Š SYSTEM MONITOR: CRITICAL EVENT detected from ANY namespace - " + payload.message);
        
        // Alert all systems
        emit system.alert.broadcast, { alert: "Critical: " + payload.message };
    }
    
    // Complex wildcard - monitor all completion events
    on any.any.any.complete (payload) {
        print("ğŸ“Š SYSTEM MONITOR: Something completed in ANY namespace - " + payload.message);
    }
}

class AICoordinator {
    // Handles AI responses from multiple services
    
    on ai.text.response (payload) {
        print("ğŸ¤– AI COORDINATOR: Text AI response - " + payload.text);
        
        // Coordinate with other AI services
        emit ai.coordination.started, { source: "text", response: payload.text };
    }
    
    on ai.voice.response (payload) {
        print("ğŸ¤– AI COORDINATOR: Voice AI response - " + payload.audio);
        
        // Coordinate with other AI services  
        emit ai.coordination.started, { source: "voice", response: payload.audio };
    }
    
    // Use wildcard to catch ALL AI responses across any service
    on ai.any.response (payload) {
        print("ğŸ¤– AI COORDINATOR: AI response from ANY service - " + payload.response);
        
        // Central AI response processing
        this.Learn({
            response: payload.response,
            context: "multi_service_ai_coordination"
        });
    }
}

// ===============================================
// CREATE AGENT INSTANCES
// ===============================================

var chatAgent = new ChatAgent();
var voiceAgent = new VoiceAgent();  
var systemMonitor = new SystemMonitor();
var aiCoordinator = new AICoordinator();

print("\nğŸš€ All agents created and event handlers registered!");
print("ğŸ“¡ Event handlers span multiple scopes and namespaces");
print("ğŸ”„ Wildcard patterns will join multiple event busses\n");

// ===============================================
// TRIGGER EVENTS ACROSS DIFFERENT NAMESPACES
// ===============================================

print("=== Testing Events Across Different Scopes ===\n");

// Test 1: System startup triggers multiple namespace events
print("ğŸ§ª TEST 1: System Startup Events");
emit system.startup.complete, { services: "All core services" };

print("\nğŸ§ª TEST 2: User Chat Interaction");  
emit user.chat.message, { text: "Hello from chat!" };

print("\nğŸ§ª TEST 3: Voice Input Processing");
emit user.voice.input, { audio: "Voice command detected" };

print("\nğŸ§ª TEST 4: AI Service Responses");
emit ai.text.response, { text: "Text AI response", response: "Generated text content" };
emit ai.voice.response, { audio: "Voice AI response", response: "Generated audio content" };

print("\nğŸ§ª TEST 5: Critical System Event");
emit agent.monitoring.critical, { message: "High CPU usage detected" };

print("\nğŸ§ª TEST 6: Complex Wildcard Pattern Test");
emit agent.voice.thinking.analysis.complete, { 
    thought: "Voice analysis complete",
    message: "Complex thinking process finished" 
};

print("\nğŸ§ª TEST 7: Cross-Namespace Communication");
emit voice.chat.command, { command: "Convert this to text" };

print("\n=== Demo Complete ===");
print("âœ… Events fired across multiple scopes and namespaces");
print("âœ… Wildcard patterns successfully joined multiple event busses");
print("âœ… Global, class, and instance handlers all activated");
print("ğŸ“Š Check output above to see namespace isolation and wildcard matching in action!");
