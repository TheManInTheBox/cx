// CX Language - Correct Dual Async Pattern Demo
// Revolutionary demonstration: Proper dual async semantics
// - Direct calls (this.Learn()) return Task<T> immediately - non-blocking  
// - Await calls (await this.Learn()) block and return T - traditional async

print("ğŸ¯ CX Correct Dual Async Pattern Demo");
print("âœ¨ Demonstrating proper Task-based and blocking patterns");

// =============================================================================
// DUAL ASYNC PATTERN DEMONSTRATION
// =============================================================================

class CognitiveAgent
{
    name: string;
    taskCount: number;
    
    constructor(agentName)
    {
        this.name = agentName;
        this.taskCount = 0;
        print("ğŸ¤– Agent " + this.name + " initialized");
    }
    
    // Pattern 1: Task-based processing (direct calls return Tasks)
    function taskBasedProcessing(data)
    {
        print("ğŸ“¡ " + this.name + " starting task-based processing: " + data);
        
        // Direct calls return Task objects immediately - non-blocking
        var learnTask = this.Learn("task_data_" + this.name + "_" + data);
        print("ğŸš€ " + this.name + " LEARN TASK STARTED (Task object returned)");
        
        var thinkTask = this.Think("task_analysis_" + this.name + "_" + data);  
        print("ğŸ’­ " + this.name + " THINK TASK STARTED (Task object returned)");
        
        this.taskCount = this.taskCount + 1;
        print("ğŸ“Š " + this.name + " tasks initiated: " + this.taskCount);
        
        // Tasks are running in background - can do other work here
        print("ğŸ”„ " + this.name + " doing other work while tasks run...");
        
        // When we access the task results, it forces an await (auto-blocking)
        print("â³ " + this.name + " now accessing task results - this will force await...");
        var learnResult = await learnTask;  // Forced await - blocks until completion
        var thinkResult = await thinkTask;  // Forced await - blocks until completion
        
        print("âœ… " + this.name + " all tasks completed via forced await!");
        return "tasks_completed_with_results";
    }
    
    // Pattern 2: Traditional blocking (await calls block until complete)
    async function blockingProcessing(data)
    {
        print("ğŸ§  " + this.name + " starting blocking processing: " + data);
        
        // Await calls block and return results directly
        var learnResult = await this.Learn("blocking_data_" + this.name + "_" + data);
        print("âœ… " + this.name + " LEARN BLOCKING COMPLETE");
        
        var thinkResult = await this.Think("blocking_analysis_" + this.name + "_" + data);
        print("ğŸ’¡ " + this.name + " THINK BLOCKING COMPLETE");
        
        return "blocking_complete";
    }
    
    // Mixed pattern: Start tasks, do work, then await results
    async function mixedProcessing(data)
    {
        print("âš¡ " + this.name + " starting mixed processing: " + data);
        
        // Start tasks in parallel (non-blocking)
        var learnTask = this.Learn("mixed_learn_" + data);
        var searchTask = this.Search("mixed_search_" + data);
        
        print("ğŸ”„ " + this.name + " tasks running in background while doing local work...");
        
        // Do some local processing while tasks run
        var localWork = "processed_locally_" + data;
        print("ğŸ› ï¸ " + this.name + " local work complete: " + localWork);
        
        // Now await the background tasks when we need results
        var learnResult = await learnTask;
        var searchResult = await searchTask;
        
        print("ğŸ¯ " + this.name + " all processing complete!");
        return "mixed_complete";
    }
}

// =============================================================================
// DEMONSTRATION EXECUTION
// =============================================================================

print("\nğŸš€ Starting Dual Async Pattern Demonstration");

// Create agent
print("\nğŸ“‹ Phase 1: Creating Cognitive Agent");
var agent = new CognitiveAgent("DualAsync");

// Demonstrate Task-based pattern
print("\nğŸ“¡ Phase 2: Task-Based Processing (Direct Calls + Forced Await)");
var taskResult = agent.taskBasedProcessing("dataset_1");
print("ğŸ¯ Task result: " + taskResult);
print("ğŸ’¡ Key insight: Tasks ran in background, then forced await when accessing results");

// Demonstrate blocking pattern
print("\nğŸ§  Phase 3: Blocking Processing (Await Calls)");
var blockingResult = agent.blockingProcessing("dataset_2");
print("âœ… Blocking result: " + blockingResult);

// Demonstrate mixed pattern
print("\nâš¡ Phase 4: Mixed Processing (Tasks + Local Work + Await)");
var mixedResult = agent.mixedProcessing("dataset_3");
print("ğŸŠ Mixed result: " + mixedResult);

// Show task awaiting concept
print("\nğŸ” Phase 5: Forced Await Concept");
print("ğŸ¯ Key Pattern: Direct calls return Task<T>, accessing results forces await");
print("ğŸ“‹ var task = this.Learn(data);     // Returns Task<T> immediately");
print("ğŸ“‹ var result = await task;         // Forced await - blocks until complete");
print("ğŸ“‹ // OR access .Result property:   // Auto-blocks until completion");
print("âš¡ This gives maximum flexibility: start tasks, do work, then get results when needed");

print("\nğŸ‰ DUAL ASYNC PATTERN DEMONSTRATION COMPLETE!");
print("ğŸ¯ Key Pattern Summary:");
print("   ğŸ“¡ Direct calls: Return Task<T> immediately - non-blocking");
print("   ğŸ§  Await calls: Block and return T - traditional async");  
print("   âš¡ Mixed: Start tasks, do work, await when needed");
print("   ğŸ”„ Flexibility: Choose the right pattern for your use case");
print("   âš¡ Forced await: Accessing results auto-blocks until completion");
print("ğŸš€ World's first dual async programming language!");
