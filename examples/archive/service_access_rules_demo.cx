// CX Language - Service Access Rules Demo
// Shows the difference between global vs class-based service access

print("ğŸ” CX Service Access Rules Demonstration");
print("=======================================");

// ğŸŒ GLOBAL/PROCEDURAL SCOPE - uses keyword allowed
uses textGen from Cx.AI.TextGeneration;
uses tts from Cx.AI.TextToSpeech;

// Global function can use services directly
async function globalAIFunction(input)
{
    print("ğŸŒ Global scope function executing...");
    
    // âœ… VALID: Direct service access in global scope
    var response = await textGen.GenerateAsync("Process: " + input);
    await tts.SpeakAsync("Global response: " + response);
    
    return response;
}

// ğŸ—ï¸ CLASS SCOPE - uses keyword ILLEGAL, must use inheritance
class ValidAgent
{
    // âŒ ILLEGAL: Cannot use 'uses' inside classes!
    // uses textGen from Cx.AI.TextGeneration;  // â† Would cause compiler error
    
    // âœ… VALID: Current working syntax (until inheritance is complete)
    async function processWithCurrentSyntax(input)
    {
        print("ğŸ—ï¸ Class method with current syntax...");
        
        // Current working approach - services injected by compiler
        var response = await this.textGen.GenerateAsync("Class process: " + input);
        await this.tts.SpeakAsync("Class response: " + response);
        
        return response;
    }
}

// ğŸ¯ FUTURE: Inheritance-based service access
class FutureAgent : AiServiceBase, ITextGeneration, ITextToSpeech
{
    async function processWithFutureSyntax(input)
    {
        print("ğŸ¯ Future class method with inheritance...");
        
        // Future syntax - services accessible via self.MethodName()
        var response = await self.GenerateAsync("Future process: " + input);
        await self.SpeakAsync("Future response: " + response);
        
        return response;
    }
}

try
{
    print("\nğŸ“‹ Testing Service Access Patterns:");
    print("-----------------------------------");
    
    // Test 1: Global function
    print("ğŸ§ª Test 1: Global function with uses keyword");
    var globalResult = await globalAIFunction("Hello from global scope");
    print("âœ… Global test passed: " + globalResult);
    
    // Test 2: Current class syntax
    print("\nğŸ§ª Test 2: Class method with current syntax");
    var agent = new ValidAgent();
    var classResult = await agent.processWithCurrentSyntax("Hello from class scope");
    print("âœ… Class test passed: " + classResult);
    
    // Test 3: Future inheritance syntax (when ready)
    print("\nğŸ§ª Test 3: Future inheritance syntax");
    print("â³ Future syntax not yet implemented in compiler");
    
    print("\nğŸ‰ SERVICE ACCESS RULES DEMONSTRATION COMPLETE!");
    print("ğŸ“ Key Points:");
    print("   â€¢ Global scope: Use 'uses' keyword");
    print("   â€¢ Class scope: Use inheritance (NO uses keyword)");
    print("   â€¢ Future: self.MethodName() for inherited services");
}
catch (error)
{
    print("âŒ Demo failed: " + error.message);
}
