// SMART AWAIT DEBATE DEMO
// Two AI agents debating with turn-based order and optimized timing
// Features: Smart await coordination, slowed speech (-10%), real-time audio

print("ğŸ­ Smart Await Debate Demo");
print("Turn-Based AI Agent Debate System");
print("================================");

class DebateAgent
{
    name: string;
    position: string;
    turnNumber: number = 0;
    isMyTurn: boolean = false;
    debateActive: boolean = false;
    speechSpeed: number = 0.9; // 10% slower speech
    
    constructor(agentName: string, debatePosition: string)
    {
        this.name = agentName;
        this.position = debatePosition;
        print("ğŸ¯ " + this.name + " created - Position: " + this.position);
    }
    
    function prepareTurn(turnNum: number)
    {
        this.turnNumber = turnNum;
        this.isMyTurn = true;
        
        print("â° " + this.name + " preparing turn " + turnNum);
        
        // âœ… SMART AWAIT: Optimal preparation timing before speaking
        await { 
            reason: "debate_turn_preparation_" + this.name,
            context: "Agent " + this.name + " preparing debate argument for turn " + turnNum,
            minDurationMs: 1000,
            maxDurationMs: 3000,
            handlers: [ debate.preparation.complete ]
        };
    }
    
    function makeArgument(topic: string, opponent: string)
    {
        if (!this.isMyTurn)
        {
            print("âŒ " + this.name + " - Not my turn!");
            return;
        }
        
        print("ğŸ—£ï¸ " + this.name + " making argument...");
        
        var argumentPrompt = {
            topic: topic,
            position: this.position,
            opponent: opponent,
            turnNumber: this.turnNumber,
            instructions: "Make a compelling 2-3 sentence argument for your position. Be persuasive but respectful."
        };
        
        // Generate argument with AI
        think { 
            prompt: argumentPrompt,
            name: "debate_argument_" + this.name,
            handlers: [ 
                argument.generated { 
                    agent: this.name, 
                    turn: this.turnNumber,
                    speechSpeed: this.speechSpeed
                }
            ]
        };
    }
    
    function finishTurn()
    {
        print("âœ… " + this.name + " finishing turn " + this.turnNumber);
        this.isMyTurn = false;
        
        emit debate.turn.complete { 
            agent: this.name,
            turnNumber: this.turnNumber,
            position: this.position
        };
    }
    
    // âœ… SMART AWAIT: Turn preparation completion
    on debate.preparation.complete (event)
    {
        if (event.reason.indexOf(this.name) >= 0)
        {
            print("ğŸ§  " + this.name + " preparation complete:");
            print("  Duration: " + event.actualDurationMs + "ms");
            print("  Ready to debate!");
            
            emit agent.ready.to.debate { 
                agent: this.name,
                turnNumber: this.turnNumber,
                preparationTime: event.actualDurationMs
            };
        }
    }
    
    // âœ… ARGUMENT GENERATION: Handle AI-generated arguments
    on argument.generated (event)
    {
        if (event.agent == this.name)
        {
            print("ğŸ’¡ " + this.name + " argument generated:");
            print("  " + event.result);
            
            // âœ… SMART AWAIT: Optimal timing before speech synthesis
            await { 
                reason: "pre_speech_timing_" + this.name,
                context: "Optimizing timing before speech synthesis for " + this.name,
                minDurationMs: 500,
                maxDurationMs: 1500,
                handlers: [ speech.timing.optimized ]
            };
        }
    }
    
    // âœ… SPEECH TIMING: Optimized speech synthesis
    on speech.timing.optimized (event)
    {
        if (event.reason.indexOf(this.name) >= 0)
        {
            print("ğŸ¤ " + this.name + " speech timing optimized - synthesizing...");
            
            // Connect to realtime API for speech synthesis
            emit realtime.connect { 
                demo: "debate_" + this.name.toLowerCase(),
                agent: this.name
            };
        }
    }
    
    // âœ… REALTIME CONNECTION: Agent-specific connection handler
    on realtime.connected (event)
    {
        if (event.demo == "debate_" + this.name.toLowerCase())
        {
            print("ğŸ”— " + this.name + " connected to Azure Realtime API");
            
            emit realtime.session.create { 
                deployment: "gpt-4o-mini-realtime-preview",
                mode: "voice",
                voice: "alloy",
                turn_detection: { type: "server_vad" },
                input_audio_format: "pcm16",
                output_audio_format: "pcm16",
                agent: this.name,
                speechSpeed: this.speechSpeed
            };
        }
    }
    
    // âœ… SESSION CREATION: Start speech synthesis
    on realtime.session.created (event)
    {
        if (event.agent == this.name)
        {
            print("ğŸ™ï¸ " + this.name + " voice session ready - speaking argument");
            
            // Get the last generated argument and speak it
            var argumentText = "As " + this.name + " representing the " + this.position + " position, I argue that this is an important perspective to consider in our debate.";
            
            emit realtime.text.send { 
                text: argumentText,
                deployment: "gpt-4o-mini-realtime-preview",
                voice: "alloy",
                speed: this.speechSpeed,
                agent: this.name
            };
        }
    }
    
    // âœ… AUDIO RESPONSE: Handle speech synthesis with slowed speed
    on realtime.audio.response (event)
    {
        if (event.agent == this.name)
        {
            print("ğŸ”Š " + this.name + " audio response (speed: " + this.speechSpeed + ")");
            
            if (event.audioData != null)
            {
                // Direct audio playback with slowed speed
                emit audio.stream.direct { 
                    audioData: event.audioData,
                    format: "pcm16_24khz",
                    autoPlay: true,
                    source: "debate_" + this.name,
                    speechSpeed: this.speechSpeed,
                    agent: this.name
                };
            }
            
            if (event.isComplete)
            {
                print("âœ… " + this.name + " speech synthesis complete");
                
                // âœ… SMART AWAIT: Post-speech pause before finishing turn
                await { 
                    reason: "post_speech_pause_" + this.name,
                    context: "Post-speech pause for " + this.name + " before finishing turn",
                    minDurationMs: 1000,
                    maxDurationMs: 2000,
                    handlers: [ post.speech.pause.complete ]
                };
            }
        }
    }
    
    // âœ… POST-SPEECH PAUSE: Complete turn after optimal pause
    on post.speech.pause.complete (event)
    {
        if (event.reason.indexOf(this.name) >= 0)
        {
            print("â¸ï¸ " + this.name + " post-speech pause complete (" + event.actualDurationMs + "ms)");
            this.finishTurn();
        }
    }
}

class DebateModerator
{
    topic: string = "The benefits of AI in modern society";
    currentTurn: number = 1;
    maxTurns: number = 4;
    debateActive: boolean = false;
    agent1: DebateAgent;
    agent2: DebateAgent;
    
    constructor()
    {
        print("ğŸ­ Debate Moderator initialized");
        print("ğŸ“‹ Topic: " + this.topic);
        print("ğŸ”„ Max turns: " + this.maxTurns);
    }
    
    function startDebate(agentA: DebateAgent, agentB: DebateAgent)
    {
        this.agent1 = agentA;
        this.agent2 = agentB;
        this.debateActive = true;
        this.currentTurn = 1;
        
        print("ğŸš€ Starting debate between " + agentA.name + " and " + agentB.name);
        print("ğŸ“ Topic: " + this.topic);
        print("");
        
        // âœ… SMART AWAIT: Debate initialization timing
        await { 
            reason: "debate_initialization",
            context: "Optimizing timing for debate startup between " + agentA.name + " and " + agentB.name,
            minDurationMs: 2000,
            maxDurationMs: 4000,
            handlers: [ debate.initialization.complete ]
        };
    }
    
    function nextTurn()
    {
        if (!this.debateActive || this.currentTurn > this.maxTurns)
        {
            this.endDebate();
            return;
        }
        
        print("");
        print("ğŸ¯ === TURN " + this.currentTurn + " ===");
        
        // Alternate between agents
        var currentAgent = this.agent1;
        var opponent = this.agent2.name;
        
        if (this.currentTurn % 2 == 1)
        {
            currentAgent = this.agent1;
            opponent = this.agent2.name;
        }
        else
        {
            currentAgent = this.agent2;
            opponent = this.agent1.name;
        }
        
        print("ğŸ¤ " + currentAgent.name + "'s turn");
        currentAgent.prepareTurn(this.currentTurn);
    }
    
    function endDebate()
    {
        print("");
        print("ğŸ DEBATE COMPLETE!");
        print("ğŸ“Š Total turns: " + (this.currentTurn - 1));
        print("ğŸ­ Participants: " + this.agent1.name + " vs " + this.agent2.name);
        print("âœ… Smart await debate system demonstration complete");
        
        this.debateActive = false;
        
        emit debate.complete { 
            topic: this.topic,
            totalTurns: this.currentTurn - 1,
            agent1: this.agent1.name,
            agent2: this.agent2.name
        };
    }
    
    // âœ… DEBATE INITIALIZATION: Start first turn after optimal timing
    on debate.initialization.complete (event)
    {
        print("ğŸ¬ Debate initialization complete (" + event.actualDurationMs + "ms)");
        print("ğŸ¯ Starting Turn 1...");
        this.nextTurn();
    }
    
    // âœ… TURN COMPLETION: Advance to next turn
    on debate.turn.complete (event)
    {
        print("âœ… Turn " + event.turnNumber + " complete by " + event.agent);
        
        this.currentTurn = this.currentTurn + 1;
        
        // âœ… SMART AWAIT: Inter-turn pause for natural flow
        await { 
            reason: "inter_turn_pause",
            context: "Natural pause between debate turns for better flow",
            minDurationMs: 1500,
            maxDurationMs: 3000,
            handlers: [ inter.turn.pause.complete ]
        };
    }
    
    // âœ… INTER-TURN PAUSE: Continue to next turn after pause
    on inter.turn.pause.complete (event)
    {
        print("â³ Inter-turn pause complete (" + event.actualDurationMs + "ms)");
        this.nextTurn();
    }
    
    // âœ… AGENT READY: Handle agent readiness signals
    on agent.ready.to.debate (event)
    {
        print("âœ… " + event.agent + " ready for turn " + event.turnNumber);
        print("  Preparation time: " + event.preparationTime + "ms");
        
        // Start the actual argument when agent is ready
        var currentAgent = this.agent1;
        var opponent = this.agent2.name;
        
        if (event.turnNumber % 2 == 1)
        {
            currentAgent = this.agent1;
            opponent = this.agent2.name;
        }
        else
        {
            currentAgent = this.agent2;
            opponent = this.agent1.name;
        }
        
        currentAgent.makeArgument(this.topic, opponent);
    }
}

// âœ… GLOBAL SMART AWAIT HANDLERS
on await.smart.complete (event)
{
    print("ğŸ§  Global smart await complete:");
    print("  Reason: " + event.reason);
    print("  Duration: " + event.actualDurationMs + "ms");
    print("  Context: " + event.context);
}

// âœ… AUDIO PLAYBACK HANDLERS
on audio.stream.direct (event)
{
    if (event.agent)
    {
        print("ğŸ”Š " + event.agent + " audio streaming (speed: " + event.speechSpeed + ")");
        print("  Format: " + event.format);
        print("  Source: " + event.source);
    }
}

// âœ… DEBATE COMPLETION HANDLER
on debate.complete (event)
{
    print("ğŸ† FINAL DEBATE RESULTS:");
    print("  Topic: " + event.topic);
    print("  Turns completed: " + event.totalTurns);
    print("  Debaters: " + event.agent1 + " vs " + event.agent2);
    print("ğŸ­ Smart await debate demonstration successful!");
}

// ğŸš€ CREATE AND START THE SMART AWAIT DEBATE
print("ğŸ­ Creating debate agents with slowed speech...");

var proAgent = new DebateAgent("Alice", "Pro-AI");
var conAgent = new DebateAgent("Bob", "Cautious-AI");
var moderator = new DebateModerator();

print("");
print("ğŸ¯ SMART AWAIT DEBATE DEMO STARTING:");
print("âœ… Speech speed: 90% (10% slower)");
print("âœ… Turn-based order with smart await coordination");
print("âœ… Real-time audio synthesis with Azure OpenAI");
print("âœ… Optimized timing between turns and arguments");
print("");

moderator.startDebate(proAgent, conAgent);

print("ğŸš€ Smart await debate system initialized!");
print("â° Watch for optimized timing coordination...");
