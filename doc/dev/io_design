Cx standard basic I/O design document

07-27-2013 Ideas for I/O design
Initial design for I/O in Cx includes the use of 2 symbol table nodes
pointed to by pInputNode, and pOutputNode. These nodes serve the purpose of I/O.

example:

// C++ design of cx_output
class cx_output : TSymtabNode {

public:
    // executes expressions and buffers values until tcSemicolon.
    // on tcSemicolon Flush() is called to perform the actual output.
    ExecuteOutput(void);
    
    // overloaded for each type
    AppendBuffer(all types){
        ss << type value;
    }
private:
    // used to buffer values until Flush() is called.
    // buffering to stringstream will help buffer all types
    // as string output.
    stringstream ss;

    Flush(void){
        std:cout << ss.str();
    }

};

The above class will allow Cx to use a named output variable that is used
and can be assigned expression results without much change to expression parsing
or executing.

in void TExecutor::ExecuteAssignment(const TSymtabNode *pTargetId),

we can test for output/input on entry like:
    if(pTargetId == pOutputNode){
        pTargetId->ExecuteOutput();
        return;
    }else if(pTargetId == pInputNode){
        pTargetId->ExecuteInput();
        return;
    }

If pTargetId points to pOutputNode when there is an assignment cx_output::ExecuteOutput
is called to parse the expression(s) that may be separated by some operator. 
cx_output::ExecuteOutput will execute expressions and buffer the results until 
token tcSemicolon is reached; at which point Flush() is called to display output.

The above design allows Cx to implement it's own I/O functions. Below is an 
example of how this would be implemented in the Cx stdlib.

// Cx implementation - just an example
/*
 * if the output variable were named 'print'
 * we can use the following 
 */
      // some expression      <<                      <<    <<    << std::ends;
print (some_var + (x/y << 2)) + " some const string " + 'c' + '\n'; // flush on ;

The above example might require a small change to expression parsing.
Where before calculated values are pushed to the stack, calculated values are 
buffered to pOutputNode->AppendBuffer(). If values are of incompatible types
or both operands are of char, char[], or const char[] the concatenation happens
by appending both values to the stringstream.

'print' is just an example. This could easily be 'cout' with the operator '<<';



