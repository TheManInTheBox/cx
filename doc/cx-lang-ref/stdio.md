# **`<stdio>`** Standard Input/Output

## Types
**file** - type, capable of holding all information needed to control a Cx I/O stream

-
## Predefined file streams
**stdin** - type file associated with the input stream

-
**stdout** - type file associated with the output stream

-
**stderr** - type file associated with the error output stream

-

## Constants
**EOF** - integer constant expression of type **int** and negative value 

-
**FOPEN_MAX** - number of files that can be open simultaneously 

-
**FILENAME_MAX** - size needed for an array of char to hold the longest supported file name

-
**SEEK_SET** - argument to **file::seek** indicating seeking from beginning of the file

-
**SEEK_CUR** - argument to **file::seek** indicating seeking from the current file position

-
**SEEK_END** - argument to **file::seek** indicating seeking from end of the file 

-
**TMP_MAX** - maximum number of unique filenames that can be generated by **std::tmpnam** 

-
**L_tmpnam** - size needed for an array of char to hold the result of **std::tmpnam** 

-

## Functions
### char putchar(char c)
**c** - character to write to **stdout**<br>
Writes a character to the standard output (**stdout**). It is equivalent to calling **putc** with **stdout** as second argument.

**Return value**<br>
ASCII code of character written
```cpp
char putchar(char c){
    return stdout.putc(c);
}
```
-
### bool puts(char *str)
**str** - copied char array to write to **stdout**<br>
Writes the copied Cx string **str** to the standard output (**stdout**), null-character `\0` is not copied to the stream. Appends newline `\n` to **str**.

**Return value**<br>
**true** on success, **false** on failure
```cpp
bool puts(char *str){
    return stdout.puts(str + '\n');
}
```

-
### char getchar(void)
Returns the next character from the standard input (**stdin**) and echo's the character to the screen. It is equivalent to calling **getc**, but **getc** will not echo the character.

**Return value**<br>
character read from stdin
```cpp
char getchar(){
    return stdin.getc;
}
```

-
### char *gets(void)
Reads characters from the standard input (**stdin**) and stores them as a Cx string into **str** until a newline character or the end-of-file is reached. The newline character, if found, is not copied into **str**. A terminating null character is automatically appended after the characters copied to **str**.

**Return value**<br>
array of characters read from stdin
```cpp
char *gets(){
    char *str;
    char c;
    bool condition = false;

    do{
        c = getchar();
		condition = ((c != '\n') && (c != '\r'));
        if(condition)str += c;
    }while(condition);

    return str;
}
```
-

### bool remove(char *filename)
**filename** - string containing the path identifying the file to delete<br>
Deletes the file identified by character string pointed to by **filename**.

**Return value**<br>
**true** on success, **false** on failure

**Note**
In POSIX the behavior for file types other than regular files is unspecified.

**Example**
```cpp
#include stdio

using std;

int main(){
	
	if(remove("file_name")){
		puts("removed file");
	} else {
		perror("remove");
	}

    return 0;
}
```
-
### void perror(char *str)
**str** - string with explanatory message<br>
Prints a textual description of the error code currently stored in the system variable **errno** to **stderr**.

**Example**
```cpp
#include stdio

using std;

int main(){
	file myfile;
	char *filename = "somefile";

	if(!myfile.open(filename, "w")){
		perror("error opening file: " + filename);
	}

    return 0;
}
```

-
### bool rename(char *old_filename, char *new_filename)
**old_filename** - string containing the path identifying the file to rename<br>
**new_filename** - string containing the new path of the file<br>
Changes the filename of a file. The file is identified by character string pointed to by **old_filename**. The new filename is identified by character string pointed to by **new_filename**.

**Return value**<br>
**true** on success, **false** on failure

**Example**
```cpp
#include stdio

using std;

int main(){

	char *filename = "somefile";

	if(!rename(filename, "new_file_name")){
		perror("unable to rename " + filename);
	} else {
		puts("renamed " + filename + " to new_file_name\n");
	}

    return 0;
}
```
-
### char *tmpnam(void)
Creates an unique filename that does not name a currently existing file, and returns it a character string. The function is capable of generating up to **TMP_MAX** of unique filenames, but some or all of them may already be in use, and thus not suitable return values.

**std::tmpnam** is not reentrant and thus not thread-safe.

**Return value**<br>
character array capable of holding at least **L_tmpnam** bytes, to be used as a result buffer

**Example**
```cpp
#include stdio

using std;

int main(){

	char *filename = tmpnam();

	if(!rename(filename, "new_file_name")){
		perror("unable to rename " + filename);
	} else {
		puts("renamed " + filename + " to new_file_name\n");
	}

    return 0;
}
```
-

## **`file`** members

### bool open(char *filename, char *mode)

**filename** - file name to associate the file stream to<br>
**mode** - character string determining file access mode<br>

Opens a file indicated by **filename** and returns a **boolean** indicating success or failure. **mode** is used to determine the file access mode.

<table>
<tr>
<th> File access <br />mode string
</th>
<th> Meaning
</th>
<th> Explanation
</th>
<th> Action if file <br /> already exists
</th>
<th> Action if file <br /> does not exist
</th></tr>
<tr>
<td> <code>"r"</code>
</td>
<td> read
</td>
<td> Open a file for reading
</td>
<td> read from start
</td>
<td> failure to open
</td></tr>
<tr>
<td> <code>"w"</code>
</td>
<td> write
</td>
<td> Create a file for writing
</td>
<td> destroy contents
</td>
<td> create new
</td></tr>
<tr>
<td> <code>"a"</code>
</td>
<td> append
</td>
<td> Append to a file
</td>
<td> write to end
</td>
<td> create new
</td></tr>
<tr>
<td> <code>"r+"</code>
</td>
<td> read extended
</td>
<td> Open a file for read/write
</td>
<td> read from start
</td>
<td> error
</td></tr>
<tr>
<td> <code>"w+"</code>
</td>
<td> write extended
</td>
<td> Create a file for read/write
</td>
<td> destroy contents
</td>
<td> create new
</td></tr>
<tr>
<td> <code>"a+"</code>
</td>
<td> append extended
</td>
<td> Open a file for read/write
</td>
<td> write to end
</td>
<td> create new
</td></tr>
<tr>
<td colspan="5"> File access mode flag <code>"b"</code> can optionally be specified to open a file in binary mode. This flag has effect only on Windows systems. <br /> On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator.
</td></tr>
</table>

**Return value**<br>
**true** on success, **false** on failure

**Example**
``` cpp
#include stdio

// merge std symbols with global scope
using std;

int main(){
	file output;
	
	// if open fails, print error
	if(!output.open("filename", "w")){
		perror("open");
	} else {
		output.puts("Hello, File!");
		output.close();
	}

	return 0;
}
```
-
### bool file::reopen(char *filename, char *mode)
**filename** - file name to associate the file stream to<br>
**mode** - character string determining file access mode<br>

Reassigns an existing file stream to a different file identified by **filename** using specified mode. **mode** is used to determine the new file access mode. 

<table>
<tr>
<th> File access <br />mode string
</th>
<th> Meaning
</th>
<th> Explanation
</th>
<th> Action if file <br /> already exists
</th>
<th> Action if file <br /> does not exist
</th></tr>
<tr>
<td> <code>"r"</code>
</td>
<td> read
</td>
<td> Open a file for reading
</td>
<td> read from start
</td>
<td> failure to open
</td></tr>
<tr>
<td> <code>"w"</code>
</td>
<td> write
</td>
<td> Create a file for writing
</td>
<td> destroy contents
</td>
<td> create new
</td></tr>
<tr>
<td> <code>"a"</code>
</td>
<td> append
</td>
<td> Append to a file
</td>
<td> write to end
</td>
<td> create new
</td></tr>
<tr>
<td> <code>"r+"</code>
</td>
<td> read extended
</td>
<td> Open a file for read/write
</td>
<td> read from start
</td>
<td> error
</td></tr>
<tr>
<td> <code>"w+"</code>
</td>
<td> write extended
</td>
<td> Create a file for read/write
</td>
<td> destroy contents
</td>
<td> create new
</td></tr>
<tr>
<td> <code>"a+"</code>
</td>
<td> append extended
</td>
<td> Open a file for read/write
</td>
<td> write to end
</td>
<td> create new
</td></tr>
<tr>
<td colspan="5"> File access mode flag <code>"b"</code> can optionally be specified to open a file in binary mode. This flag has effect only on Windows systems. <br /> On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator.
</td></tr>
</table>

**Return value**<br>
**true** on success, **false** on failure

**Example**
``` cpp
#include stdio

using std;

int main(){
	file output;
	
	// if open fails, print error
	if(!output.open("filename", "w")){
		perror("open");
	} else {
		output.close();
		if(!output.reopen("newfilename", "w"))){
			perror("reopen");
		} else {
			output.puts("Hello, NewFile!");
			output.close();
		}
	}

	return 0;
}
```
-
### bool file::close(void)
Closes the given file stream. Any unwritten buffered data are flushed to the OS. Any unread buffered data are discarded.

**Return value**<br>
**true** on success, **false** on failure

-
### bool file::flush(void)
Synchronizes an output stream with the actual file.

**Return value**<br>
**true** on success, **false** on failure

-
### int file::wide(int mode)
Switches a file stream between wide character I/O and narrow character I/O 
**mode** - integer value greater than zero to set the stream wide, less than zero to set the stream narrow, or zero to query only 

If **mode** > 0, attempts to make stream wide-oriented. If **mode** < 0, attempts to make stream byte-oriented. If **mode** == 0, only queries the current orientation of the stream. 

**Return value**<br>
An integer greater than zero if the stream is wide-oriented after this call, less than zero if the stream is byte-oriented after this call, and zero if the stream has no orientation. 
  
-
### byte *file::read(int count, int size)
**size** - size of each object in bytes<br>
**count** - the number of the objects to be read<br>

Reads up to count objects into the array buffer from the given input stream stream as if by calling **file::getc** size times for each object, and storing the results, in the order obtained, into the successive positions of buffer, which is reinterpreted as an array of **byte**. The file position indicator for the stream is advanced by the number of characters read.

If the objects are not **Trivially Copyable**, the behavior is undefined.

If an error occurs, the resulting value of the file position indicator for the stream is indeterminate. If a partial element is read, its value is indeterminate.

**Return value**<br>
Objects read successfully, which may be less than count if an error or end-of-file condition occurs.
If size or count is zero, **file::read** returns **null** and performs no other action.

-
### int file::write(int count, int size, byte *buffer)

-
### char file::getc(void)

-
### char *file::gets(int count)

-
### file::putc

-
### file::puts

-
### file::ungetc

-
## Wide character 

### file::getwc

-
### file::getws

-
### file::putwc

-
### file::putws

-
### wchar getwchar(void)

-
### wchar putwchar(wchar wc)

-
### file::ungetwc

-

3/19/2014 4:15:53 PM 