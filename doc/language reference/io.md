# **io** - Standard Input/Output

## Types
**file** - type, capable of holding all information needed to control a Cx I/O stream

-
## Predefined file streams
**stdin** - type file associated with the input stream

-
**stdout** - type file associated with the output stream

-
**stderr** - type file associated with the error output stream

-

## Constants
**EOF** - integer constant expression of type **int** and negative value 

-
**FOPEN_MAX** - number of files that can be open simultaneously 

-
**FILENAME_MAX** - size needed for an array of char to hold the longest supported file name

-
**SEEK_SET** - argument to **file::seek** indicating seeking from beginning of the file

-
**SEEK_CUR** - argument to **file::seek** indicating seeking from the current file position

-
**SEEK_END** - argument to **file::seek** indicating seeking from end of the file 

-
**TMP_MAX** - maximum number of unique filenames that can be generated by **io::tmpnam** 

-
**L_tmpnam** - size needed for an array of char to hold the result of **io::tmpnam** 

-

## Functions
### char putchar(char c)
Writes a character to the standard output (**stdout**). It is equivalent to calling **putc** with **stdout** as second argument.

#### Parameters
**c** - character to write to **stdout**

#### Return value
ASCII code of character written

#### Example
```cpp
char putchar(char c){
    return stdout.putc(c);
}
```
-
### bool puts(char *str)

Writes the copied Cx string **str** to the standard output (**stdout**), null-character `\0` is not copied to the stream. Appends newline `\n` to **str**.

#### Parameters
**str** - copied char array to write to **stdout**

#### Return value
**true** on success, **false** on failure

#### Example
```cpp
bool puts(char *str){
    return stdout.puts(str + '\n');
}
```

-
### char getchar(void)
Returns the next character from the standard input (**stdin**) and echo's the character to the screen. It is equivalent to calling **getc**, but **getc** will not echo the character.

#### Return value
character read from stdin

#### Example
```cpp
char getchar(){
    return stdin.getc;
}
```

-
### char *gets(void)
Reads characters from the standard input (**stdin**) and stores them as a Cx string into **str** until a newline character or the end-of-file is reached. The newline character, if found, is not copied into **str**. A terminating null character is automatically appended after the characters copied to **str**.

#### Return value
array of characters read from stdin

#### Example
```cpp
char *gets(){
    char *str;
    char c;
    bool condition = false;

    do{
        c = getchar();
		condition = ((c != '\n') && (c != '\r'));
        if(condition)str += c;
    }while(condition);

    return str;
}
```
-

### bool remove(char *filename)
Deletes the file identified by character string pointed to by **filename**.

#### Parameters
**filename** - string containing the path identifying the file to delete

#### Return value
**true** on success, **false** on failure

#### Note
In POSIX the behavior for file types other than regular files is unspecified.

#### Example
```cpp
#include io

int main(){
	
	if(io::remove("file_name")){
		io::puts("removed file");
	} else {
		io::perror("remove");
	}

    return 0;
}
```
-
### void perror(char *str)
Prints a textual description of the error code currently stored in the system variable **errno** to **stderr**.

#### Parameters
**str** - string with explanatory message

#### Example
```cpp
#include io

int main(){
	io::file myfile;
	char *filename = "somefile";

	if(!myfile.open(filename, "w")){
		io::perror("error opening file: " + filename);
	}

    return 0;
}
```

-
### bool rename(char *old_filename, char *new_filename)
Changes the filename of a file. The file is identified by character string pointed to by **old_filename**. The new filename is identified by character string pointed to by **new_filename**.

#### Parameters
**old_filename** - string containing the path identifying the file to rename
**new_filename** - string containing the new path of the file

#### Return value
**true** on success, **false** on failure

#### Example
```cpp
#include io

int main(){

	char *filename = "somefile";

	if(!io::rename(filename, "new_file_name")){
		io::perror("unable to rename " + filename);
	} else {
		io::puts("renamed " + filename + " to new_file_name\n");
	}

    return 0;
}
```
-
### char *tmpnam(void)
Creates an unique filename that does not name a currently existing file, and returns it a character string. The function is capable of generating up to **TMP_MAX** of unique filenames, but some or all of them may already be in use, and thus not suitable return values.

#### Note
**io::tmpnam** is not re-entrant and thus not thread-safe.

#### Return value
character array capable of holding at least **L_tmpnam** bytes, to be used as a result buffer

#### Example
```cpp
#include io

int main(){

	char *filename = io::tmpnam();

	if(!io::rename(filename, "new_file_name")){
		io::perror("unable to rename " + filename);
	} else {
		io::puts("renamed " + filename + " to new_file_name\n");
	}

    return 0;
}
```
-

## **`io::file`** members

### bool open(char *filename, char *mode)
Opens a file indicated by **filename** and returns a **boolean** indicating success or failure. **mode** is used to determine the file access mode.

#### Parameters
**filename** - file name to associate the file stream to
**mode** - character string determining file access mode

<table>
<tr>
<th> File access <br />mode string
</th>
<th> Meaning
</th>
<th> Explanation
</th>
<th> Action if file <br /> already exists
</th>
<th> Action if file <br /> does not exist
</th></tr>
<tr>
<td> <code>"r"</code>
</td>
<td> read
</td>
<td> Open a file for reading
</td>
<td> read from start
</td>
<td> failure to open
</td></tr>
<tr>
<td> <code>"w"</code>
</td>
<td> write
</td>
<td> Create a file for writing
</td>
<td> destroy contents
</td>
<td> create new
</td></tr>
<tr>
<td> <code>"a"</code>
</td>
<td> append
</td>
<td> Append to a file
</td>
<td> write to end
</td>
<td> create new
</td></tr>
<tr>
<td> <code>"r+"</code>
</td>
<td> read extended
</td>
<td> Open a file for read/write
</td>
<td> read from start
</td>
<td> error
</td></tr>
<tr>
<td> <code>"w+"</code>
</td>
<td> write extended
</td>
<td> Create a file for read/write
</td>
<td> destroy contents
</td>
<td> create new
</td></tr>
<tr>
<td> <code>"a+"</code>
</td>
<td> append extended
</td>
<td> Open a file for read/write
</td>
<td> write to end
</td>
<td> create new
</td></tr>
<tr>
<td colspan="5"> File access mode flag <code>"b"</code> can optionally be specified to open a file in binary mode. This flag has effect only on Windows systems. <br /> On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator.
</td></tr>
</table>

#### Return value
**true** on success, **false** on failure

#### Example
``` cpp
#include io

int main(){
	io::file output;
	
	// if open fails, print error
	if(!output.open("filename", "w")){
		io::perror("open");
	} else {
		output.puts("Hello, File!");
		output.close();
	}

	return 0;
}
```
-
### bool file::reopen(char *filename, char *mode)
Reassigns an existing file stream to a different file identified by **filename** using specified mode. **mode** is used to determine the new file access mode. 

#### Parameters
**filename** - file name to associate the file stream to
**mode** - character string determining file access mode

<table>
<tr>
<th> File access <br />mode string
</th>
<th> Meaning
</th>
<th> Explanation
</th>
<th> Action if file <br /> already exists
</th>
<th> Action if file <br /> does not exist
</th></tr>
<tr>
<td> <code>"r"</code>
</td>
<td> read
</td>
<td> Open a file for reading
</td>
<td> read from start
</td>
<td> failure to open
</td></tr>
<tr>
<td> <code>"w"</code>
</td>
<td> write
</td>
<td> Create a file for writing
</td>
<td> destroy contents
</td>
<td> create new
</td></tr>
<tr>
<td> <code>"a"</code>
</td>
<td> append
</td>
<td> Append to a file
</td>
<td> write to end
</td>
<td> create new
</td></tr>
<tr>
<td> <code>"r+"</code>
</td>
<td> read extended
</td>
<td> Open a file for read/write
</td>
<td> read from start
</td>
<td> error
</td></tr>
<tr>
<td> <code>"w+"</code>
</td>
<td> write extended
</td>
<td> Create a file for read/write
</td>
<td> destroy contents
</td>
<td> create new
</td></tr>
<tr>
<td> <code>"a+"</code>
</td>
<td> append extended
</td>
<td> Open a file for read/write
</td>
<td> write to end
</td>
<td> create new
</td></tr>
<tr>
<td colspan="5"> File access mode flag <code>"b"</code> can optionally be specified to open a file in binary mode. This flag has effect only on Windows systems. <br /> On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator.
</td></tr>
</table>

#### Return value
**true** on success, **false** on failure

#### Example
``` cpp
#include io

int main(){
	io::file output;
	
	// if open fails, print error
	if(!output.open("filename", "w")){
		io::perror("open");
	} else {
		output.close();
		if(!output.reopen("newfilename", "w"))){
			io::perror("reopen");
		} else {
			output.puts("Hello, NewFile!");
			output.close();
		}
	}

	return 0;
}
```
-
### bool file::close(void)
Closes the given file stream. Any unwritten buffered data are flushed to the OS. Any unread buffered data are discarded.

#### Return value
**true** on success, **false** on failure

-
### bool file::flush(void)
Synchronizes an output stream with the actual file.

#### Return value
**true** on success, **false** on failure

-
### int file::wide(int mode)
Switches a file stream between wide character I/O and narrow character I/O 

#### Parameters
**mode** - integer value greater than zero to set the stream wide, less than zero to set the stream narrow, or zero to query only 

If **mode** > 0, attempts to make stream wide-oriented. If **mode** < 0, attempts to make stream byte-oriented. If **mode** == 0, only queries the current orientation of the stream. 

#### Return value
An integer greater than zero if the stream is wide-oriented after this call, less than zero if the stream is byte-oriented after this call, and zero if the stream has no orientation. 
  
-
### byte *file::read(int count, int size)
Reads up to count objects into the array buffer from the given input stream stream as if by calling **file::getc** size times for each object, and storing the results, in the order obtained, into the successive positions of buffer, which is reinterpreted as an array of **byte**. The file position indicator for the stream is advanced by the number of characters read.

If the objects are not **Trivially Copy-able**, the behavior is undefined.

If an error occurs, the resulting value of the file position indicator for the stream is indeterminate. If a partial element is read, its value is indeterminate.

#### Parameters
**size** - size of each object in bytes
**count** - the number of the objects to be read

#### Return value
Objects read successfully, which may be less than count if an error or end-of-file condition occurs.
If size or count is zero, **file::read** returns **null** and performs no other action.

-
### int file::write(int count, int size, byte *buffer)
Writes up to count binary objects from the given array buffer to the output stream stream. The objects are written as if by reinterpreting each object as an array of unsigned char and calling **io::fputc** size times for each object to write those unsigned chars into stream, in order. The file position indicator for the stream is advanced by the number of characters written.

If the objects are not **Trivially Copy-able**, the behavior is undefined.
If an error occurs, the resulting value of the file position indicator for the stream is indeterminate.

#### Parameters
**buffer** -	 pointer to the first object object in the array to be written
**size** -	 size of each object
**count** -	 the number of the objects to be written

#### Return value
Number of objects written successfully, which may be less than count if an error occurred.
If size or count is zero, **file::fwrite** returns zero and performs no other action.

-
### char file::getc(void)
Reads the next character from the given input stream.

#### Return value
The obtained character on success or **io::EOF** on failure.

If the failure has been caused by end of file condition, additionally sets the eof indicator (see **file::eof()**) on stream. If the failure has been caused by some other error, sets the error indicator (see **file::error()**) on stream.

#### Example
``` cpp
#include io

int main(){
	
	io::file input;
	char *filename = "input.txt";

	if(!myfile.open(filename, "r"))
		io::perror("error opening file: " + filename);
	else {
		while(!myfile.eof){
			// this may atually try to print the io::EOF char to stdout
			io::puts(myfile.getc.to_str);
		}
		myfile.close;
	}
	
	return 0;
}
```
-
### char *file::gets(int count)
Reads at most count - 1 characters from the given file stream and returns it. The produced character string is always null-terminated. Parsing stops if end-of-file occurs or a newline character is found, in which case the returned string will contain that newline character.

#### Parameters
**count** - the length of str

#### Return value
A string on success, **null** on failure.
If the failure has been caused by end of file condition, additionally sets the eof indicator (see **file::eof()**) on **stdin**. If the failure has been caused by some other error, sets the error indicator (see file::error()**) on **stdin**.

#### Example
``` cpp
#include io

int main () {

    char *in;

    do{
        io::puts("Please enter your name: ");
        // read string until '\n'
         in = io::stdin.gets();

	// in == null
    }while(!in);
    
    char *t1 = "beep";
    char *t2 = "-boop";
    char *greet = "Hello " + in + ", you a bad " + t1 + t2 + " !";

    io::puts(greet);

    return 0;
}
```

-
### int file::putc(int ch)
Writes a character ch to the given output stream stream.
Internally, the character is converted to `unsigned char` just before being written.

#### Parameters
**ch** - character to be written

#### Return value
On success, returns the written character.
On failure, returns **io::EOF** and sets the error indicator (see **file::error()**) on **io::stdout**.

-
### bool file::puts(char *str)
Writes given null-terminated character string to the given output stream.

#### Parameters
**str** - character string to be written

#### Return value
**true** on success, **false** on failure.

-
### int file::ungetc(int ch)
Puts the character ch back to the given file stream.

#### Parameters
**ch** - character to be put back

#### Return value
On success **ch** is returned.
On failure **io::EOF** is returned and the given stream remains unchanged.

-
## Wide character 

### wchar file::getwc(void)
Reads the next wide character from the given input stream.

#### Return value
The next wide character from the stream or **io::WEOF** if an error has occurred or the end of file has been reached. If an encoding error occurred, **errno()** is set to **EILSEQ**.

-
### wchar *file::getws(int count)
Reads at most count - 1 wide characters from the given file stream and returns them as a wide string. The produced wide string is always NULL-terminated. Parsing stops if end-of-file occurs or a newline wide character is found, in which case the wide string will contain that wide newline character.

#### Parameters
**count** - the length of wide string

#### Return value
wide string on success **null** on an error

-
### wchar file::putwc(wchar ch)
Writes a wide character **ch** to the given output stream.

#### Parameters
**ch** - wide character to be written

#### Return value
**ch** on success, **io::WEOF** on failure. If an encoding error occurs, **errno()** is set to **EILSEQ**.

-
### bool file::putws(wchar *wstr)
Writes given null-terminated wide string to the given output stream.

#### Parameters
**wstr** - null-terminated wide string to be written

#### Return value
**true** on success, **false** on failure

-
### wchar getwchar(void)
Reads the next wide character from **io::stdin**.

#### Return value
The obtained wide character or **io::WEOF** if an error has occurred or the end of file reached

-
### wchar putwchar(wchar wc)
Writes a wide character **ch** to **io::stdout**

#### Parameters
**ch** - wide character to be written

#### Return value
**ch** on success, **io::WEOF** on failure.

-
### wchar file::ungetwc(wchar ch)
Puts the wide character **ch** back to the given file stream. Only one wide character pushback is guaranteed.

#### Parameters
**ch** - wide character to be put back

#### Return value
On success **ch** is returned.
On failure **io::WEOF** is returned and the given stream remains unchanged.

-

4/25/2014 4:42:00 PM  